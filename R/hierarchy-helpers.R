#' Load relationship file
#'
#' @param file path to .csv file describing a spatial relationship
#' @return table describing the spatial relationship
#' @export
load_spatial_relationship = function(file) {
  table = load_csv(file, "spatial_relationship_file")
  name_check = colnames(table) == c("region_code", "region_level", 
    "parent_region_code", "parent_region_level",
    "start_date", "end_date")
  if (!all(name_check))
    stop("Spatial table does not contain correct column names.")
  table[['start_date']] = lubridate::ymd(table[['start_date']])
  table[['end_date']] = lubridate::ymd(table[['end_date']])
  table[['id']] = paste(table[['region_code']], table[['region_level']])
  table[['parent_id']] = paste(table[['parent_region_code']], table[['parent_region_level']]) 
  ## FIXME: add schema checks here.
  return(table) 
}

#' Make h_table zero row.
#' 
#' @return an 'h_table' zero_Row
zero_row = function() {
  zero_row = data.frame(
    region_code = "ZERO", region_level = "ZERO_LEVEL",
    parent_region_code = "ZERO", parent_region_level = "ZERO_LEVEL",
    start_date = NA, end_date = NA,
    id = "ZERO ZERO_LEVEL", parent_id = "ZERO ZERO_LEVEL",
    stringsAsFactors = FALSE
  )
  return(zero_row)
}

#' Make h_table no-parent rows
#'
#' @param table h_table to check for no-parent codes.
#' @return data frame rows for all no-parent rows (with ZERO as parent).
np_rows = function(table) {
  np_idxs = which(!(table[['parent_id']] %in% table[['id']]))
  np_rows = data.frame(
    region_code = table[['parent_region_code']][np_idxs], 
    region_level = table[['parent_region_level']][np_idxs],
    parent_region_code = "ZERO", 
    parent_region_level = "ZERO_LEVEL",
    start_date = NA, end_date = NA,
    id = paste(table[['parent_region_code']][np_idxs], table[['parent_region_level']][np_idxs]),
    parent_id = "ZERO ZERO_LEVEL",
    stringsAsFactors = FALSE)
  np_rows = unique(np_rows)
  return(np_rows)
}

#' Return the index of the zero-value entry in the parameter index
#'
#' @return index of the zero entry in the 'h_table'
get_zero_idx = function() return(1)


#' Generate a single hierarchy table for an implied hierarchy
#'
#' The first item describes the terminal level for all levels.
#' Each item describes one level of the hierarchy.  That's an 'h_table'.
#'
#' @param files paths to .csv files describing spatial relationships
#' @return single hierarchy table
#' @export
spatial_hierarchy = function(files) {
  tables = lapply(files, load_spatial_relationship)
  table = do.call(rbind, c(tables, stringsAsFactors = FALSE))
  h_table = do.call(rbind, c(list(zero_row(), table, np_rows(table), stringsAsFactors = FALSE)))
  class(h_table) = c(class(h_table), 'h_table')
  return(h_table)
}

#' Get names of levels from a hierarchy table.
#' 
#' @param table table generated by `spatial_hierarchy`
#' @return names names of hierarchy levels
#' @export
region_names = function(table) {
  nm = table[['region_level']]
  nm = unique(nm)
  return(nm)
}

#' For a code return the index if a code exists or a zero otherwise
#' 
#' @param code 
#' @param table h_table object.
get_id_idx = function(code, table) {
  idx = which(code == table[['id']])
  if (length(idx) == 0)
    idx = get_zero_idx()
  return(idx)
}

#' Get the leaf indexes for an 'h_table'
#'
#' A leaf index is one that does _not_ appear as a parent.
#' 
#' @param table 'h_table'
get_leaf_idxs = function(table) {
  ids = table[['id']]
  leaf_idxs = which(!(ids %in% table[['parent_id']]))
  return(leaf_idxs)
}

